// Temporary file for archived lines

// console.log(relatedNotes1);

// console.log(namedReference.etn); // NOT WORKING
// console.log(namedReference.id);
// console.log(getFormattedValueo);
// console.log(getRecordIdo);
// console.log(getValueo);

//  DataSetGrid.displayName = 'DataSetGrid'; Eslint React Component displayName warning
//  export default DataSetGrid; Eslint React Component displayName warning

// const myItemInvoked = React.useCallback((item: any): void => { // Seperated onItemInvoke component
//   const record = dataset.records[item.key];
//   dataset.openDatasetItem(record.getNamedReference());
// }, [dataset]);

// getRelatedNotes(context,namedReference,targetEntityType).then(function(data) => {myNoteItems = data;} )
// console.log('related Notes1');
// console.log(relatedNotes1);
//  setNoteItems(myNoteItems);
// console.log('NOTE ITEMS');
// console.log(noteItems);
// let myitem : any;
// (async () => {
//   console.log('NOTESSS');
//   myitem = await myNoteItems;
//   console.log(myitem.entities[0]);
//   console.log(myitem.entities);
// })();
// console.log(`MYITEM${myitem}`);
// console.log('my item!!!');
// console.log(myitem);

// const finalNotes = myNoteItems.entities.map((entity: any) => ({
//   name: entity.filename,
//   fieldName: entity.filename,
//   key: entity.annotationid,
// }));
// console.log('final notes');
// console.log(finalNotes);
// console.log('My note items');
// console.log(myNoteItems);

// const getFormattedValueo  = dataset.records[item.key].getFormattedValue;
// const getRecordIdo = dataset.records[item.key].getRecordId();
// const getValueo = dataset.records[item.key].getValue;

// console.log(relatedNotes1);

// console.log(namedReference.etn);
// console.log(namedReference.id);
// console.log(getFormattedValueo);
// console.log(getRecordIdo);
// console.log(getValueo);

// console.log('DATASET COLUMNS');
// console.log(dataset.columns);
// console.log('columns');
// console.log(columns);
//  const myObj = Object.assign(myColumns, columns);
// console.log('MYOBJ');
// console.log(myObj);
// myColumns.push({
//   name: 'Delete',
//   fieldName: 'Delete',
//   minWidth: 50,
//   key: 'Delete',
//   onRender:});

// console.log('attrsib');
// console.log(attributes);
// const deleteButton = <Link onClick={() => { console.log('clicked'); }}>Edit</Link>;
// attributes.push({ 'Delete': 'delete' });
// attributes.push({ 'menua': 'menua' });
// console.log(attributes);

// const myItemInvoked = React.useCallback((item: any): void => {
//   const record = dataset.records[item.key];
//   dataset.openDatasetItem(record.getNamedReference());
// }, [dataset]);

// const realRealOnes = realones.then
// React.useEffect(() => {
//   setNoteItems(finalNotes);
// }, [finalNotes])

// console.log('MyNoteItems');
// console.log(noteItems);
// myNoteItems();

// const openCalloutBox: React.FunctionComponent = () => {
//   }

// const linkHtml = <Link onClick={() => { console.log('clicked'); }}>Edit</Link>;

// const newProp = 'red';

// const onRenderRow = useCallback((items, defaultRender) =>
//   <div className='red'>
//     {defaultRender({ ...items, onClick: () => console.log(items.item) }) }
//   </div>
// , [items.item]);

// const [selectedItem, setSelectedItem] = React.useState<Object | undefined>(undefined);
// console.log('Dataset records');
// console.log(dataset.records);
// console.log('items');
// console.log(items);
// console.log('columns');
// console.log(dataset.columns);
// console.log('selectedCount: ');
// console.log(selection);
// console.log('LAST ITEM');
// const lastItem = items.slice(-1);
// console.log(lastItem);

// console.log(props);
// if(items[0] !== null || items[0] !== undefined){
//   items[0].onRender = () => <a href="//www.microsoft.com">View</a>;
// }
// const _onFilter = (ev: React.FormEvent<HTMLInputElement | HTMLTextAreaElement>,
//   text: string): void => {
//   React.setState({
//     items: text ? this._allItems.filter(i => i.name.toLowerCase().indexOf(text) > -1) : this._allItems,
//   });
// };

// function onrender(item: any, column: any, setItems: any): JSX.Element {
//   console.log(item);
//   if (column.key === 'Delete') {
//     console.log('OK!');
//     return <Link onClick={() => { console.log('clicked', item); }}>Edit</Link>;
//   }
//   return setItems(item);
// }

// const onRenderColumnListRow: IDetailsListProps['onRenderRow'] = (props) => {
//   const customStyles: Partial<IDetailsRowStyles> = {};
//   if (props) {
//       customStyles.root = { backgroundColor: '#f2f8ff', color: '#171717' };
//       return <DetailsList {...props} styles={customStyles} />;
//   }
//   return null;
// };

// function openCalloutBox()
// {

// }

// const onRenderEvent = onrender(items, columns);

// const relatedNotes = getRelatedNotes(context, namedReference).then(data => data);
// console.log('named reference');
// console.log(namedReference);
// console.log(namedReference.etn); // NOT WORKING BITCH

// React.useEffect(() => {

//   console.log('React Use Effect');
// }, []);
// setNoteItems(finalNotes);
// myNoteItems = data;

// const relatedNotes1 = getRelatedNotes(context, namedReference,
//   targetEntityType).then(data => { console.log('data in THEN');
//   console.log(data); myNoteItems = data; return data; });

// if(finalNotes.length == )
// setNoteItems(finalNotes);

// const merged1 = { ...columns1, ...myColumns };

// onRenderItemColumn={onrender}
//  onRenderRow= {onRenderRow}
// onRenderRow={ (items) => (
//   <div {...items}>
//   </div>
// ) }

//  DataSetGrid.displayName = 'DataSetGrid'; displayName warning
//  export default DataSetGrid;

// const myNoteItems = async () => {
//   const data = await getRelatedNotes(context, namedReference, targetEntityType);
//   const finalNotes = data.entities.map((entity: any) => ({
//     name: entity.filename,
//     fieldName: entity.filename,
//     key: entity.annotationid,
//   }));
//   console.log('final notes');
//   console.log(finalNotes);

//   return data;
// };

// {
//   key: 'upload',
//   text: 'Upload',
//   iconProps: { iconName: 'Upload' },
//   subMenuProps: {

//     items: [
//       {
//         key: 'uploadfile',
//         text: 'File',
//         preferMenuTargetAsEventTarget: true,
//         onClick: (ev?: React.MouseEvent<HTMLElement, MouseEvent> |
//            React.KeyboardEvent<HTMLElement> | undefined) => {
//           ev?.persist();

//           Promise.resolve().then(() => {
//             const inputElement = document.createElement('input');
//             inputElement.style.visibility = 'hidden';
//             inputElement.setAttribute('type', 'file');

//             document.body.appendChild(inputElement);

//             const target = ev?.target as HTMLElement | undefined;

//             if (target) {
//               setVirtualParent(inputElement, target);
//             }

//             inputElement.click();

//             if (target) {
//               setVirtualParent(inputElement, null);
//             }

//             setTimeout(() => {
//               inputElement.remove();
//             }, 10000);
//             console.log(target);
//           });
//         },
//       },
//       {
//         key: 'uploadfolder',
//         text: 'Folder',
//         preferMenuTargetAsEventTarget: true,
//         onClick: (ev?: React.MouseEvent<HTMLElement, MouseEvent> | React.KeyboardEvent<HTMLElement> | undefined) => {
//           ev?.persist();

//           Promise.resolve().then(() => {
//             const inputElement = document.createElement('input');
//             inputElement.style.visibility = 'hidden';
//             inputElement.setAttribute('type', 'file');

//             (inputElement as { webkitdirectory?: boolean }).webkitdirectory = true;

//             document.body.appendChild(inputElement);

//             const target = ev?.target as HTMLElement | undefined;
//             console.log(ev?.currentTarget);
//             console.log(ev?.target);
//             if (target) {
//               console.log("target1");
//               let data1 = new FormData();
//               //console.log(`1${ev?.target.files[0]}`);
//               //data1.append('file', target);
//               setVirtualParent(inputElement, target);

//             }

//             inputElement.click();

//             if (target) {
//               console.log("target2");
//               let data2 = new FormData();
//               //data2.append('file', target);
//               setVirtualParent(inputElement, null);
//             }

//             setTimeout(() => {
//               inputElement.remove();
//             }, 10000);
//           });
//         },
//       },
//     ],
//   },
//   // href: 'https://developer.microsoft.com/en-us/fluentui',
// },

// const CustomButton: React.FunctionComponent<IButtonProps> = props => {
//   const buttonOnMouseClick = () => alert(`${props.text} clicked`);
//   // eslint-disable-next-line react/jsx-no-bind
//   return <CommandBarButton {...props} onClick={buttonOnMouseClick} styles={getCommandBarButtonStyles(props.styles)} />;
// };

// const itemStyles: Partial<IContextualMenuItemStyles> = {
//   label: { fontSize: 18 },
//   root: { marginLeft: -3 },
//   icon: { color: theme.palette.red },
//   iconHovered: { color: theme.palette.redDark },
// };

// const menuStyles: Partial<IContextualMenuStyles> = {
//   subComponentStyles: { menuItem: itemStyles, callout: {} },
//   list: { itemStyles },
//   container: { itemStyles },
// };

// const getCommandBarButtonStyles = memoizeFunction(
//   (originalStyles: IButtonStyles | undefined): Partial<IContextualMenuItemStyles> => {
//     if (!originalStyles) {
//       return menuStyles;
//     }

//     return concatStyleSets(originalStyles, itemStyles);
//   },
// );

